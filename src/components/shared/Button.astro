---
interface Props {
  href?: string;
  variant?: "primary" | "secondary";
  size?: "sm" | "md" | "lg";
  class?: string;
  text?: string;
  [key: string]: any;
}

const { href, variant = "primary", size = "lg", text, class: className = "", ...rest } = Astro.props;

// Check for conflicting usage
const hasSlotContent = Astro.slots.has("default");

if (text && hasSlotContent) {
  throw new Error("Button: Cannot use both text prop and slot children");
}

// Extract CloudCannon-specific attributes for the text wrapper
const { "data-editable": dataEditable, "data-prop": dataProp, ...elementRest } = rest;

const baseClasses = "inline-flex items-center font-extrabold border transition-all duration-300 ease-in-out tracking-wider";

const variantClasses = {
  primary: "text-secondary bg-primary hover:bg-secondary hover:text-primary border-primary",
  secondary: "text-primary bg-secondary hover:bg-primary hover:text-white border-primary",
};

const sizeClasses = {
  sm: "px-6 py-3 text-base rounded-xl",
  md: "px-7 py-3.5 text-lg rounded-xl",
  lg: "px-8 py-4 text-lg rounded-2xl",
};

const classes = `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`;
---

{
  href ? (
    <a data-astro-prefetch href={href} class={classes} {...elementRest}>
      {text ? (
        dataEditable && dataProp ? (
          <editable-text data-editable={dataEditable} data-prop={dataProp}>
            {text}
          </editable-text>
        ) : (
          text
        )
      ) : (
        <slot />
      )}
    </a>
  ) : (
    <button class={classes} {...elementRest}>
      {text ? (
        dataEditable && dataProp ? (
          <editable-text data-editable={dataEditable} data-prop={dataProp}>
            {text}
          </editable-text>
        ) : (
          text
        )
      ) : (
        <slot />
      )}
    </button>
  )
}
